1.wbbs对文章列表部分的处理

现在的wbbs文章列表是基于同主题的，列表时只列出
同主题首篇文章；列表按照同主题最后一篇文章的发文
时间降序排序，有分页功能。

这部分处理主要由phpbbslib中的下面几个函数来完成：

bbs_getthreadnum(string boardName)，该函数求某版面下的主题数量
这个函数首先比较.DIR和.WEBTHREAD文件的时间戳，如果
.WEBTHREAD旧于.DIR则调用bbslib中的www_generateOriginIndex
函数重新生成.WEBTHREAD文件（似乎需要一个更好的判断方式来触发更新.WEBTHREAD）
然后直接由.WEBTHREAD的文件长度求记录数目。

其主要算法是：
首先建立一标志数组，在其中存放已找到的groupID。这个标志数组有两个
内部数据结构：第一个是链表，按照每个主题最后发文时间排序，最后可以
直接顺序写入 .WEBTHREAD。另一个结构是平衡二叉树，目的是方便快速搜索
groupID。程序倒序遍历.DIR中的记录，如果其groupID不在标志数组中，则
加入标志数组。在遍历过程中同时判断该帖子是否是原文，如果是，同时需要
将原文信息复制进标志数组。最后生成.WEBTHREAD的时候是按照链表顺序写，判断该主
题是否有原文，如果没有，作一些特殊处理再写入 .WEBTHREAD 以便到时候显示原文
是否被删除。关于这里是否有原文的处理细节，参见代码。


bbs_getthreads(string boardName, int start, int num)，该函数按
同主题最后一篇文章的发文时间降序排列，取从start开始的num篇主题信息。
这个函数充分利用已经产生的 .WEBTHREAD 文件来操作。


atppp注: 以下三个函数已经被替换成 smthbbs 系统最新的主题查找函数
bbs_get_threads_from_gid()。我看了一下，下面的函数单个来看效率其实比
bbs_get_threads_from_gid()更高，但是综合起来测试整个PHP执行的效率，使用
bbs_get_threads_from_gid()一般来说更好。这里我先这样改了，希望roy不要打我pp。

bbs_get_thread_articles(char *board, int groupID, int start, int num)
该函数按发文时间降序排列，取某一从start开始的num篇文章

其算法为：
首先找倒序遍历.DIR从中找主题ID与groupID相同的
start+num篇文章；

bbs_get_thread_articles_num(char *board, int groupID)
该函数求某主题的文章数

其算法与bbs_get_thread_articles也类似，首先找到该主题的首篇文章，然后从
此处开始遍历.DIR找主题ID与groupID相同文章并计数；

bbs_get_article() 也已经被替换掉




2.关于同主题模式的利弊

同主题模式和公网论坛比较一致但是和传统telnet配合的时候可能会有不一致的地方。
以下几个问题是特别需要注意的

*) 删除了原文的置顶不能阅读
*) 一个主题是否显示成精华，不可re，and/or 置顶仅仅是判断原文是否有这个属性。
   特别的，如果一个re文被g，这个主题不会自动成为精华贴。类似的，一片re文被
   设置为不可re，这个主题不会显示为不可re；但是如果原文被设置成不可re，这个
   主题会显示为不可re(当然这个标志只有版主能看见)不过所有已有的re文还都是可
   re的。这里还有不少细节问题。

这个以后可能会改。




3. 关于树形回复结构

loadtree.php (版面文章列表点击 + 会显示回复结构) 和 disparticle.php (单篇文章
阅读底部会显示回复结构) 已经加入了树形回复结构的支持。基础代码在
inc/treeview.inc.php 里面。产生回复树结构再递归显示其实是一件比较耗时间的操作，
这部分代码以后可能还需要再优化。现在如果回复超过一定的数量(50)，就不显示回复树
结构而直接显示平板式回复结构。另外，smthbbs 现在设置的一个主题可以返回的最大回
复数量是512。这里其实还是有文章可做，比方回复树里面显示每一个帖子是否已读，不过
暂时先不考虑了。

default.php 里面定义了 SHOWREPLYTREE，如果为 1 就会支持树形回复结构。如果为 0 
就是平级显示所有回复。这里也有分章可做，SHOWREPLYTREE 其实定义成用户自定义参数
或者 cookie 参数可能更好。



4. 一些杂事

a. 一个主题，如果最后一个回复是未读的，自动认为这个主题未读
b. 版面搜索功能只搜索楼主，时间范围指定的是最后回复时间范围。
c. query.php里面设置了window.onload，因为如果<select size不是1的话，IE和firefox有
   时候不能正确highlight预选的版面。如果在funcs.js或类似地方全局性的设置window.onload
   一定注意保证query.php的onload逻辑不变。比方 fader.js 就设置了 window.onload，
   所以query.php如果直接加系统公告就会出问题。
   DOM2加入了addEventListener可以用以避免这个问题，不过IE6似乎不支持。
d. queryresult.php 使用 javascript 来写页面。如果搜索结果过多，可能会提示是否取消
   javascript 运行。另外搜索结果全都放在一个 table 里面，如果页面没有下完，就什么都不
   会显示。这些暂时不管了吧，以后搜索做成分页的就好了。
e. 目前使用php session的只有注册页的图片识别。register.php 和 img_rand/img_rand.php
   自己调用 session_start(), inc/funcs.php 不调用 session_start()。这个以后有必要的话
   可以改。比方浏览器cookie标准是有个数上限的，可以考虑把cookie全都放到session里面。当然
   那样的话 php session_tmp 那个目录要弄成 tmpfs。另外需要注意新的 php 版本，
   session_start() 不能被调用两次。
f. 分区版面列表采用JS写页面。展开列表需要隐藏iframe读数据，折叠列表直接使用已有的js变量
   重写页面。列表是否展开由一个 ShowSecBoards cookie 控制。这个 cookie 变量的最低一个 bit 
   表示收藏夹版面列表是否展开，第(i+1) bit 表示第 i 个分区是否展开。二级目录永远展开。
   展开版面列表以后服务器端设置 cookie；折叠列表由客户端自己设置 cookie。



5. browscap.ini get_browser() 函数。默认关闭这个功能。参考：

http://www.php.net/manual/en/function.get-browser.php

verx at implix dot com
09-Dec-2002 02:57 
Please keep in mind that you should somehow (for example in session) cache the required results of get_browser() because it really slows thinks down. 

We have experienced that without querying for browser data our scripts would run 120-130% faster. the explanation is that over 200kb long file (browscap.ini) has to be loaded and parsed everytime someone access any page (we need browser results on all pages).

So keep results in session and expect a performance boost. 





6. inc/funcs.php 代码分析
做一些记录希望有用。这个文件是所有页面都要 include 的

6a. 可引用的全局变量。这些变量在 include 之后生效
$loginok       是否以正式用户登录了，guest 登录的话为 0
$guestloginok
$currentuser
$currentuinfo

6b. 可设置的全局变量。必须在 include 之前设置
$setboard
needlogin       本页面是否需要设置 cookie 等登录变量，默认需要

6c. 有用的函数说明
cache_header($scope,$modifytime=0,$expiretime=300)
	检查/设置页面 cache

html_init($charset="",$title="",$otherheader="")
	初始化 html 页面，一般不需要调用，除非是小页面

show_nav($boardName='')
	调用 html_init() 并显示页面头。如果 $boardName 不为空，搜索的链接将会自动选中此版面。如果 $boardName 为 false，不显示菜单条。所有POST递交生成
	的页面原则上都应该使用  $boardName=false，否则用户重新登录，调整页面风格等可能会造成返回后的URL不正确。

setStat($stat)
	设置页面标题

head_var($Title='', $URL='',$showWelcome=0)
	显示导航条

setSucMsg($msg)
	添加成功操作信息 $msg

html_success_quit($Desc='',$URL='')
	显示成功操作信息

requireLoginok($msg = false, $directexit = true)
	声明本页面必须正式注册用户才能访问。如果当前用户是正式用户，函数直接返回。
	否则直接调用 foundErr(错误信息, $directexit, false)，其中错误信息由 $msg 控制：
	$msg        错误信息。如果为 false 就是用默认的错误信息

	这个函数还有一个作用是，调用它之后调用show_nav()显示的页面头里面的注销link将会带到首页，否则注销仍旧会回到当前页面。
	页面调用这几个函数的顺序应该是：setStat, requireLoginok, show_nav

foundErr($msg, $directexit = true, $showmsg = true)
	添加操作错误信息 $msg
	$directexit 为 true 时，检查是否调用过 show_nav()，如果没有就调用 show_nav() 显示页面头。然后调用 show_footer($showmsg, true)，结束页面。

	注意：当 $directexit 为 true (默认) 的时候，requireLoginok() 和 foundErr() 两个函数如果碰到错误会结束页面！

isErrFounded()
	是否有错误发生

html_error_quit()
	显示错误信息。如果曾经调用过 requireLoginok() 而当前用户又是 guest，将会显示登录框。这个函数一般不需要直接调用。

show_footer($showmsg = true, $showerr = true)
	显示页面最后的版权信息等。
	$showmsg    本页面是否有自动刷新消息接受页面的功能。除非是小页面，一般都设置成 true
	$showerr    如果页面有错误，是否调用 html_error_quit() 输出错误信息。


jumpReferer()
	如果Referer有设置，跳到Referer，否则跳到首页。
